#include <bits/stdc++.h>
using namespace std;

// Class to represent an opcode (MOT or POT)
class OpcodeEntry {
public:
    string name;          // Opcode name
    string type;          // "MOT" or "POT"
    string registerType;  // "RR", "RX", etc.
    string registerSize;  // e.g., "4 bytes", "8 bytes", or "-"

    OpcodeEntry(string n, string t, string rt, string rs)
        : name(n), type(t), registerType(rt.empty() ? "-" : rt), registerSize(rs.empty() ? "-" : rs) {}
};

// MOT: Machine Opcode Table (name â†’ {regType, regSize in bytes})
unordered_map<string, pair<string, string>> MOT = {
    {"MOV", {"RR", "4 bytes"}},
    {"ADD", {"RR", "4 bytes"}},
    {"SUB", {"RR", "4 bytes"}},
    {"MUL", {"RR", "4 bytes"}},
    {"DIV", {"RR", "4 bytes"}},
    {"JMP", {"RX", "4 bytes"}},
    {"CMP", {"RR", "4 bytes"}},
    {"AND", {"RR", "4 bytes"}},
    {"OR",  {"RR", "4 bytes"}},
    {"XOR", {"RR", "4 bytes"}}
};

// POT: Pseudo Opcode Table
vector<string> POT = {"START", "END", "EQU", "ORG", "DS", "DC", "RESW", "RESB"};

// Tables
vector<string> labelTable;
vector<OpcodeEntry> motTable;
vector<OpcodeEntry> potTable;
set<string> symbolTable;
set<string> literalTable;

// Trim whitespace from both ends
string trim(string str) {
    while (!str.empty() && isspace(str.front())) str.erase(str.begin());
    while (!str.empty() && isspace(str.back())) str.pop_back();
    return str;
}

// Check if opcode already exists in MOT or POT table
bool isOpcodePresent(const string& name) {
    for (const auto& entry : motTable)
        if (entry.name == name) return true;
    for (const auto& entry : potTable)
        if (entry.name == name) return true;
    return false;
}

// Display Label Table
void displayLabels() {
    cout << "\nLabel Table (LT)\n";
    cout << "S.No.\tLabel\n";
    for (size_t i = 0; i < labelTable.size(); ++i)
        cout << (i + 1) << "\t" << labelTable[i] << "\n";
    cout << "Total Labels: " << labelTable.size() << "\n";
}

// Display MOT Table
void displayMOT() {
    cout << "\nMachine Opcode Table (MOT)\n";
    cout << "S.No.\tName\tRegType\tRegSize\n";
    for (size_t i = 0; i < motTable.size(); ++i)
        cout << (i + 1) << "\t" << motTable[i].name << "\t" << motTable[i].registerType << "\t" << motTable[i].registerSize << "\n";
    cout << "Total MOT entries: " << motTable.size() << "\n";
}

// Display POT Table
void displayPOT() {
    cout << "\nPseudo Opcode Table (POT)\n";
    cout << "S.No.\tName\n";
    for (size_t i = 0; i < potTable.size(); ++i)
        cout << (i + 1) << "\t" << potTable[i].name << "\n";
    cout << "Total POT entries: " << potTable.size() << "\n";
}

// Display Symbol Table
void displaySymbols() {
    cout << "\nSymbol Table\n";
    int i = 1;
    for (const auto& sym : symbolTable)
        cout << i++ << "\t" << sym << "\n";
    cout << "Total Symbols: " << symbolTable.size() << "\n";
}

// Display Literal Table
void displayLiterals() {
    cout << "\nLiteral Table\n";
    int i = 1;
    for (const auto& lit : literalTable)
        cout << i++ << "\t" << lit << "\n";
    cout << "Total Literals: " << literalTable.size() << "\n";
}

// Check if token is a literal
bool isLiteral(const string& token) {
    return token.size() > 1 && token[0] == '=';
}

int main() {
    string filename;
    cout << "Enter input ASM filename: ";
    cin >> filename;

    ifstream infile(filename);
    if (!infile) {
        cerr << "Error: Cannot open file " << filename << "\n";
        return 1;
    }

    string line;
    while (getline(infile, line)) {
        size_t commentPos = line.find(';');
        if (commentPos != string::npos)
            line = line.substr(0, commentPos);

        line = trim(line);
        if (line.empty()) continue;

        // Tokenize line
        istringstream iss(line);
        vector<string> tokens;
        string word;
        while (iss >> word) tokens.push_back(word);
        if (tokens.empty()) continue;

        // Handle labels
        if (tokens[0].back() == ':') {
            string label = tokens[0].substr(0, tokens[0].length() - 1);
            labelTable.push_back(label);
            tokens.erase(tokens.begin());
        }

        if (tokens.empty()) continue;

        string opcode = tokens[0];
        transform(opcode.begin(), opcode.end(), opcode.begin(), ::toupper);

        // Add to MOT or POT tables
        if (!isOpcodePresent(opcode)) {
            if (MOT.find(opcode) != MOT.end()) {
                string regType = MOT[opcode].first;
                string regSize = MOT[opcode].second;
                motTable.emplace_back(opcode, "MOT", regType, regSize);
            } else if (find(POT.begin(), POT.end(), opcode) != POT.end()) {
                potTable.emplace_back(opcode, "POT", "-", "-");
            }
        }

        // Parse operands (symbols and literals)
        for (size_t i = 1; i < tokens.size(); ++i) {
            string tok = tokens[i];

            // Remove ',' if present
            if (!tok.empty() && tok.back() == ',')
                tok.pop_back();

            if (isLiteral(tok)) {
                literalTable.insert(tok);
            } else if (MOT.find(tok) == MOT.end() &&
                       find(POT.begin(), POT.end(), tok) == POT.end()) {
                symbolTable.insert(tok);
            }
        }
    }

    infile.close();

    displayLabels();
    displayMOT();
    displayPOT();
    displaySymbols();
    displayLiterals();

    return 0;
}
